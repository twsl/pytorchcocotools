from typing import Union

from pytorchcocotools._maskApi import (
    MASK,
    RLES,
    SIZES,
    R,
    Rs,
    rleArea,
    rleDecode,
    rleEncode,
    rleFrString,
    rleMerge,
    rleToString,
)
import torch
from torch import Tensor


def _merge(rleObjs: Rs, intersect: bool = False) -> R:  # noqa: N803
    """Compute union or intersection of encoded masks."""
    rles, sizes = _frString(rleObjs)
    r = rleMerge(rles, sizes, intersect)
    obj = _toString(r)[0]
    return obj


def _iou(dt: Tensor, gt: Tensor, pyiscrowd: list[Tensor]) -> Tensor:
    """Compute intersection over union between masks.

    Finally, a note about the intersection over union (iou) computation.
    The standard iou of a ground truth (gt) and detected (dt) object is
    iou(gt,dt) = area(intersect(gt,dt)) / area(union(gt,dt))
    For "crowd" regions, we use a modified criteria. If a gt object is
    marked as "iscrowd", we allow a dt to match any subregion of the gt.
    Choosing gt' in the crowd gt that best matches the dt can be done using
    gt'=intersect(dt,gt). Since by definition union(gt',dt)=dt, computing
    iou(gt,dt,iscrowd) = iou(gt',dt) = area(intersect(gt,dt)) / area(dt)
    For crowd gt regions we use this modified criteria above for the iou.
    """

    def _preproc(objs):
        if len(objs) == 0:
            return objs
        if type(objs) == Tensor:
            if len(objs.shape) == 1:
                objs = objs.reshape((objs[0], 1))
            # check if it's Nx4 bbox
            if not len(objs.shape) == 2 or not objs.shape[1] == 4:
                raise Exception("torch.Tensor input is only for *bounding boxes* and should have Nx4 dimension")
            objs = objs.to(dtype=torch.double)
        elif isinstance(objs, list):
            # check if list is in box format and convert it to torch.Tensor
            isbox = torch.all(
                torch.Tensor(
                    [(len(obj) == 4) and (isinstance(objs, list) or (type(obj) == torch.Tensor)) for obj in objs]
                )
            )
            isrle = torch.all(torch.Tensor([isinstance(objs, dict) for obj in objs]))
            if isbox:
                objs = torch.Tensor(objs, dtype=torch.double)
                if len(objs.shape) == 1:
                    objs = objs.reshape((1, objs.shape[0]))
            elif isrle:
                objs = _frString(objs)
            else:
                raise Exception("list input can be bounding box (Nx4) or RLEs ([RLE])")
        else:
            raise Exception(
                "unrecognized type.  The following type: RLEs (rle), torch.Tensor (box), and list (box) are supported."
            )
        return objs

    def _len(obj):
        n = 0
        # if type(obj) == RLEs:
        #     n = obj.n
        # elif len(obj)==0:
        #     pass
        # elif type(obj) == torch.Tensor:
        #     n = obj.shape[0]
        return n

    # convert iscrowd to numpy array
    iscrowd = torch.Tensor(pyiscrowd, dtype=torch.uint8)
    # simple type checking
    m, n = None, None
    dt = _preproc(dt)
    gt = _preproc(gt)
    m = _len(dt)
    n = _len(gt)
    if m == 0 or n == 0:
        return []
    if not type(dt) == type(gt):
        raise Exception("The dt and gt should have the same data type, either RLEs, list or torch.ndarray")

    # check type and assign iou function
    if type(dt) == Rs:
        _iouFun = rleIou
    elif type(dt) == Tensor:
        _iouFun = bbIoU
    else:
        raise Exception("input data type not allowed.")

    iou = _iouFun(dt, gt, iscrowd, m, n, iou)
    return iou.reshape((m, n), order="F")


# # internal conversion from Python RLEs object to compressed RLE format
def _toString(rles: RLES, sizes: SIZES) -> Rs:
    rle_dict = []
    for i, rle in enumerate(rles):
        rle_dict.append({"size": [sizes[i][0], sizes[i][1]], "counts": rleToString(rle)})
    return rle_dict


# # internal conversion from compressed RLE format to Python RLEs object
def _frString(rle_dict: Rs) -> tuple[RLES, SIZES]:
    sizes = []
    rles = []
    for obj in rle_dict:
        rle = rleFrString(obj["counts"]) if type(obj["counts"]) == bytes else obj["counts"]
        rles.append(rle)
        size = [obj["size"][0], obj["size"][1]]
        sizes.append(size)
    return rles, sizes


def _encode(mask: MASK) -> Rs:
    """Encode mask to RLEs objects: list of RLE string can be generated by RLEs member function."""
    rles, sizes = rleEncode(mask)
    rle_dict = _toString(rles, sizes)
    return rle_dict


def _decode(rle_dict: Rs) -> MASK:
    """Decode mask from compressed list of RLE string or RLEs object."""
    rles, sizes = _frString(rle_dict)
    masks = rleDecode(rles, sizes)
    return masks


def _area(rle_dict: Rs) -> Tensor:
    rles, sizes = _frString(rle_dict)
    rleArea(rles, sizes)
    #     shape = []
    #     shape[0] = Rs._n
    #     a = torch.array((Rs._n, ), dtype=torch.uint8)
    #     a = torch.PyArray_SimpleNewFromData(1, shape, torch.NPY_UINT32, _a)
    #     return a

    return torch.zeros(1)


def _toBbox(rleObjs: Rs) -> Tensor:
    rles, sizes = _frString(rleObjs)
    #     n = Rs.n
    #     _bb = [] * 4*n
    #     rleToBbox( <const RLE*> Rs._R, _bb, n )
    #     shape = []
    #     shape[0] = 4*n
    #     bb = torch.array((1,4*n), dtype=torch.double)
    #     bb = torch.PyArray_SimpleNewFromData(1, shape, torch.NPY_DOUBLE, _bb).reshape((n, 4))
    #     return bb
    return torch.zeros((len(rleObjs), 4))


def _frBbox(bb: Tensor, h: int, w: int) -> Rs:
    # n = bb.shape[0]
    # Rs = RLEs(n)
    # rleFrBbox(bb, h, w, n )
    # objs = _toString(Rs)
    # return objs
    return []


def _frPoly(poly: list, h: int, w: int) -> Rs:
    len(poly)
    Rs = []
    for _i, p in enumerate(poly):
        torch.Tensor(p, dtype=torch.double, order="F")
        # rleFrPoly(np_poly.data, int(len(p)/2), h, w )
    objs = _toString(Rs)
    return objs


def _frUncompressedRLE(ucRles: Rs, h: int, w: int) -> Rs:
    return []
    #     cnts = Tensor()
    #     R = None
    #     data = None
    #     n = len(ucRles)
    #     objs = []
    #     for i in range(n):
    #         Rs = RLEs(1)
    #         cnts = torch.Tensor(ucRles[i]['counts'], dtype=torch.uint32)
    #         # time for malloc can be saved here but it's fine
    #         data = None
    #         for j in range(len(cnts)):
    #             data[j] = cnts[j]
    #         R = RLE(ucRles[i]['size'][0], ucRles[i]['size'][1], len(cnts), data)
    #         Rs._R[0] = R
    #         objs.append(_toString(Rs)[0])
    #     return objs
