from pytorchcocotools._maskApi import (
    BB,
    RLE,
    Mask,
    Masks,
    RleObj,
    RleObjs,
    RLEs,
    bbIou,
    rleArea,
    rleDecode,
    rleEncode,
    rleFrBbox,
    rleFrPoly,
    rleFrString,
    rleIou,
    rleMerge,
    rleToBbox,
    rleToString,
)
import torch
from torch import Tensor


def _toString(Rs: RLEs) -> RleObjs:  # noqa: N802, N803
    """Internal conversion from Python RLEs object to compressed RLE format.

    Args:
        Rs: _description_

    Returns:
        _description_
    """
    py_string: bytes = None
    objs = []
    for R in Rs:
        py_string = rleToString(R)
        objs.append({"size": [R.h, R.w], "counts": py_string})
    return objs


def _frString(rleObjs: RleObjs) -> RLEs:  # noqa: N802, N803
    """Internal conversion from compressed RLE format to Python RLEs object.

    Args:
        rleObjs: List of rle encoded masks.

    Returns:
        _description_
    """
    n = len(rleObjs)
    Rs = []  # noqa: N806
    py_string: bytes = None
    for obj in rleObjs:
        py_string = str.encode(obj["counts"]) if isinstance(obj["counts"], str) else obj["counts"]
        Rs.append(rleFrString(py_string, obj["size"][0], obj["size"][1]))
    return RLEs(Rs, n)


def encode(mask: Mask) -> RleObjs:
    """Encode mask to RLEs objects, list of RLE string can be generated by RLEs member function.

    Args:
        mask: _description_

    Returns:
        _description_
    """
    # np.ndarray[np.uint8_t, ndim=3, mode='fortran']
    h, w, n = mask.shape[0], mask.shape[1], mask.shape[2]
    Rs = rleEncode(mask, h, w, n)  # noqa: N806
    objs = _toString(Rs)
    return objs


def decode(rleObjs: RleObjs) -> Mask:  # noqa: N803
    """Decode mask from compressed list of RLE string or RLEs object.

    Args:
        rleObjs: _description_

    Returns:
        _description_
    """
    Rs = _frString(rleObjs)
    h, w, n = Rs[0].h, Rs[0].w, Rs.n
    masks = rleDecode(Rs, n)
    return masks


def merge(rleObjs: RleObjs, intersect: bool = False) -> RleObj:  # noqa: N803
    """Merges multiple rles into one rle mask by taking union (OR) or intersection (AND).

    Args:
        rleObjs: _description_
        intersect: _description_. Defaults to False.

    Returns:
        _description_
    """
    Rs = _frString(rleObjs)
    R: RLEs = rleMerge(Rs, Rs.n, intersect)
    obj = _toString(R)[0]
    return obj


def area(rleObjs: RleObjs) -> list[int]:  # noqa: N803
    Rs: RLEs = _frString(rleObjs)
    a = rleArea(Rs, Rs.n)
    return a


# iou computation. support function overload (RLEs-RLEs and bbox-bbox).
def iou(dt: RLEs | BB | list | Tensor, gt: RLEs | BB | list | Tensor, pyiscrowd: list[bool]) -> Tensor:
    def _preproc(objs):
        if len(objs) == 0:
            return objs
        if isinstance(objs, Tensor):
            if len(objs.shape) == 1:
                objs = objs.reshape((objs[0], 1))
            # check if it's Nx4 bbox
            if not len(objs.shape) == 2 or not objs.shape[1] == 4:
                raise Exception("Tensor input is only for *bounding boxes* and should have Nx4 dimension")  # noqa: TRY002
            objs = objs.to(dtype=torch.double)
        elif isinstance(objs, list):
            # check if list is in box format and convert it to np.ndarray
            isbox = torch.all(Tensor([(len(obj) == 4) and (isinstance(obj, list | Tensor)) for obj in objs]))
            isrle = torch.all(Tensor([isinstance(obj, dict) for obj in objs]))
            if isbox:
                objs = Tensor(objs, dtype=float)
                if len(objs.shape) == 1:
                    objs = objs.reshape((1, objs.shape[0]))
            elif isrle:
                objs = _frString(objs)
            else:
                raise Exception("list input can be bounding box (Nx4) or RLEs ([RLE])")  # noqa: TRY002
        else:
            raise TypeError(
                "Unrecognized type.  The following type: RLEs (rle), torch.Tensor (box), and list (box) are supported."
            )
        return objs

    def _len(obj):
        if type(obj) == RLEs:
            return obj.n
        elif len(obj) == 0:
            return 0
        elif isinstance(obj, Tensor):
            return obj.shape[0]
        return 0

    # convert iscrowd to numpy array
    iscrowd = Tensor(pyiscrowd, dtype=torch.uint8)
    # simple type checking
    m, n = 0
    dt = _preproc(dt)
    gt = _preproc(gt)
    m = _len(dt)
    n = _len(gt)
    if m == 0 or n == 0:
        return []
    if not type(dt) == type(gt):
        raise Exception("The dt and gt should have the same data type, either RLEs, list or np.ndarray")  # noqa: TRY002

    # define local variables
    _iou: list[float] = []
    # shape = [0]
    _iouFun = rleIou if isinstance(dt, RLEs) else bbIou if isinstance(dt, Tensor) else None  # noqa: N806
    # check type and assign iou function
    if _iouFun is None:
        raise Exception("input data type not allowed.")  # noqa: TRY002

    # _iou = <double*> malloc(m*n* sizeof(double))
    # iou = np.zeros((m*n, ), dtype=np.double)
    # shape[0] = <np.npy_intp> m*n
    # iou = np.PyArray_SimpleNewFromData(1, shape, np.NPY_DOUBLE, _iou)
    # PyArray_ENABLEFLAGS(iou, np.NPY_OWNDATA)
    iou = _iouFun(dt, gt, iscrowd, m, n)
    # return iou.reshape((m, n), order="F")
    return iou


def toBbox(rleObjs: RleObjs) -> BB:  # noqa: N803, N802
    Rs: RLEs = _frString(rleObjs)
    n = Rs.n
    bb = rleToBbox(Rs, n)
    return bb


def frBbox(bb: BB, h: int, w: int) -> RleObjs:  # noqa: N802
    n = bb.shape[0]
    Rs: RLEs = rleFrBbox(bb, h, w, n)
    objs = _toString(Rs)
    return objs


def frPoly(poly: list[list[float]] | Tensor, h: int, w: int) -> RleObjs:  # noqa: N802
    Rs = []  # RLEs(n)
    for p in poly:
        np_poly = p if isinstance(p, Tensor) else torch.tensor(p, dtype=torch.int)
        Rs.append(rleFrPoly(np_poly, int(len(p) / 2), h, w))
    objs = _toString(RLEs(Rs))
    return RleObjs(objs)


def frUncompressedRLE(ucRles: list[dict], h: int, w: int) -> RleObjs:  # noqa: N803, N802
    n = len(ucRles)
    objs = []
    for i in range(n):
        cnts = torch.tensor(ucRles[i]["counts"], dtype=torch.int)
        R = RLE(ucRles[i]["size"][0], ucRles[i]["size"][1], len(cnts), cnts)
        objs.append(_toString(RLEs([R]))[0])
    return RleObjs(objs)


def frPyObjects(pyobj, h: int, w: int) -> RleObjs:  # noqa: N802
    # encode rle from a list of python objects
    if isinstance(pyobj, Tensor):
        return frBbox(pyobj, h, w)
    elif isinstance(pyobj, list) and len(pyobj[0]) == 4:
        return frBbox(pyobj, h, w)
    elif isinstance(pyobj, list) and len(pyobj[0]) > 4:
        return frPoly(pyobj, h, w)
    elif isinstance(pyobj, list) and isinstance(pyobj[0], dict) and "counts" in pyobj[0] and "size" in pyobj[0]:
        return frUncompressedRLE(pyobj, h, w)
    # encode rle from single python object
    elif isinstance(pyobj, list) and len(pyobj) == 4:
        return frBbox([pyobj], h, w)[0]
    elif isinstance(pyobj, list) and len(pyobj) > 4:
        return frPoly([pyobj], h, w)[0]
    elif isinstance(pyobj, dict) and "counts" in pyobj and "size" in pyobj:
        return frUncompressedRLE([pyobj], h, w)[0]
    else:
        raise Exception("input type is not supported.")  # noqa: TRY002
