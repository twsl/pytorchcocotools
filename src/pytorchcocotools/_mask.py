from typing import cast

import torch
from torch import Tensor

from pytorchcocotools.internal.entities import BB, RLE, IoUObject, Mask, Poly, PyObj, RleObj, RleObjs, RLEs
from pytorchcocotools.internal.mask_api import (
    bbIou,
    rleArea,
    rleDecode,
    rleEncode,
    rleFrBbox,
    rleFrPoly,
    rleFrString,
    rleIou,
    rleMerge,
    rleToBbox,
    rleToString,
)


def _toString(Rs: RLEs) -> RleObjs:  # noqa: N802, N803
    """Internal conversion from Python RLEs object to compressed RLE format.

    Args:
        Rs: The masks to encode.

    Returns:
        The RLE encoded mask.
    """
    objs = [RleObj(size=[r.h, r.w], counts=rleToString(r)) for r in Rs]
    return objs


def _frString(rleObjs: RleObjs) -> RLEs:  # noqa: N802, N803
    """Internal conversion from compressed RLE format to Python RLEs object.

    Args:
        rleObjs: List of rle encoded masks.

    Returns:
        The decoded mask.
    """
    rles = [
        rleFrString(
            str.encode(obj.counts) if isinstance(obj.counts, str) else obj.counts,
            obj.size[0],
            obj.size[1],
        )
        for obj in rleObjs
    ]
    return rles


def encode(mask: Mask) -> RleObjs:
    """Encode mask to RLEs objects, list of RLE string can be generated by RLEs member function.

    Args:
        mask: The mask to encode.

    Returns:
        The encoded mask.
    """
    # np.ndarray[np.uint8_t, ndim=3, mode='fortran']
    h, w, n = mask.shape[0], mask.shape[1], mask.shape[2]
    Rs = rleEncode(mask, h, w, n)  # noqa: N806
    objs = _toString(Rs)
    return objs


def decode(rleObjs: RleObjs) -> Mask:  # noqa: N803
    """Decode mask from compressed list of RLE string or RLEs object.

    Args:
        rleObjs: The encoded masks.

    Returns:
        The decoded mask.
    """
    rs = _frString(rleObjs)
    _h, _w, n = rs[0].h, rs[0].w, len(rs)
    masks = rleDecode(rs, n)
    return masks


def merge(rleObjs: RleObjs, intersect: bool = False) -> RleObj:  # noqa: N803
    """Merges multiple rles into one rle mask by taking union (OR) or intersection (AND).

    Args:
        rleObjs: The masks to merge.
        intersect: Whether to compute the intersection.

    Returns:
        The merged mask.
    """
    rs = _frString(rleObjs)
    r = rleMerge(rs, intersect)
    obj = _toString([r])[0]
    return obj


def area(rleObjs: RleObjs) -> list[int]:  # noqa: N803
    """Compute area of encoded masks.

    Args:
        rleObjs: The masks to compute the area of.

    Returns:
        A list of areas of the encoded masks.
    """
    rs = _frString(rleObjs)
    a = rleArea(rs)
    return a


def iou(dt: IoUObject, gt: IoUObject, pyiscrowd: list[bool]) -> Tensor:
    """Compute intersection over union between objects.

    Note:
    Supports function overload (RLEs-RLEs and bbox-bbox)

    Args:
        dt: The detected objects.
        gt: The ground truth objects.
        pyiscrowd: The iscrowd flag for each object.

    Returns:
        The intersection over union between the detected and ground truth objects.
    """

    def _preproc(objs: list[list] | Tensor | RLEs) -> Tensor | RLEs:
        if len(objs) == 0:
            return Tensor(objs)
        if isinstance(objs, Tensor):
            if len(objs.shape) == 1:
                # TODO: figure out, why pycocotools didn't use the shape, propably just another error?
                # objs = objs.reshape((objs[0], 1))
                objs = objs.reshape((objs.shape[0], 1))
            # check if it's Nx4 bbox
            if not len(objs.shape) == 2 or not objs.shape[1] == 4:
                raise Exception("Tensor input is only for *bounding boxes* and should have Nx4 dimension")  # noqa: TRY002
            objs = objs.to(dtype=torch.float32)  # TODO: originally double is used, why???
        elif isinstance(objs, list):
            # check if list is in box format and convert it to torch.Tensor
            isbox = all((isinstance(obj, list | Tensor)) and (len(obj) == 4) for obj in objs)
            isrle = all(isinstance(obj, dict) for obj in objs)
            if isbox:
                objs = torch.tensor(objs, dtype=torch.float32)
                if len(objs.shape) == 1:
                    objs = objs.reshape((1, objs.shape[0]))
            elif isrle:
                objs = _frString(objs)  # pyright: ignore[reportArgumentType]
            else:
                raise Exception("list input can be bounding box (Nx4) or RLEs ([RLE])")  # noqa: TRY002
        else:
            raise TypeError(
                "Unrecognized type.  The following type: RLEs (rle), torch.Tensor (box), and list (box) are supported."
            )
        return objs

    def _len(obj: list | Tensor) -> int:
        if isinstance(obj, list):  # RLEs
            return len(obj)
        elif isinstance(obj, Tensor):
            return obj.shape[0]
        elif len(obj) == 0:
            return 0
        return 0

    is_crowd = pyiscrowd
    dt = _preproc(dt)
    gt = _preproc(gt)
    m = _len(dt)
    n = _len(gt)
    crowd_length = len(is_crowd)
    assert crowd_length == n, "iou(iscrowd=) must have the same length as gt"  # noqa: S101
    if m == 0 or n == 0:
        return Tensor()
    if type(dt) is not type(gt):
        raise Exception("The dt and gt should have the same data type, either RLEs, list or torch.Tensor")  # noqa: TRY002
    if isinstance(dt, RLEs):
        return rleIou(dt, gt, m, n, is_crowd)
    if isinstance(dt, Tensor):
        return bbIou(dt, gt, m, n, is_crowd)
    else:
        raise TypeError("Input data type not allowed.")  # noqa: TRY002
    return Tensor()


def toBbox(rleObjs: RleObjs) -> BB:  # noqa: N803, N802
    """Compute bounding box from encoded objects.

    Args:
        rleObjs: The masks to compute the bounding box of.

    Returns:
        The bounding box of the encoded masks.
    """
    rs = _frString(rleObjs)
    bb = rleToBbox(rs)
    return bb


def frBbox(bb: BB, h: int, w: int) -> RleObjs:  # noqa: N802
    """Convert bounding box to run length encoded objects.

    Args:
        bb: The bounding box to convert.
        h: The height of the mask.
        w: The width of the mask.

    Returns:
        The RLE encoded objects.
    """
    rs = rleFrBbox(bb, h, w)
    objs = _toString(rs)
    return objs


def frPoly(poly: list[Poly] | Tensor, h: int, w: int) -> RleObjs:  # noqa: N802
    """Convert polygon to run length encoded objects.

    Args:
        poly: The polygon to convert.
        h: The height of the mask.
        w: The width of the mask.

    Returns:
        The RLE encoded objects.
    """
    rs = []  # RLEs(n)
    for p in poly:
        np_poly = p.to(dtype=torch.float64) if isinstance(p, Tensor) else torch.tensor(p, dtype=torch.float64)
        rs.append(rleFrPoly(np_poly, int(len(p) / 2), h, w))
    objs = _toString(RLEs(rs))
    return RleObjs(objs)


def frUncompressedRLE(ucRles: RleObjs, h: int, w: int) -> RleObjs:  # noqa: N803, N802
    """Convert uncompressed RLE to run length encoded objects.

    Args:
        ucRles: The uncompressed RLE to convert.
        h: The height of the mask.
        w: The width of the mask.

    Returns:
        The RLE encoded objects.
    """
    n = len(ucRles)
    objs = []
    for i in range(n):
        cnts = torch.tensor(ucRles[i].counts, dtype=torch.int)
        r = RLE(ucRles[i].size[0], ucRles[i].size[1], len(cnts), cnts)
        objs.append(_toString(RLEs([r]))[0])
    return objs


def frPyObjects(pyobj: PyObj, h: int, w: int) -> RleObjs | RleObj:  # noqa: N802
    """Convert (list of) polygon, bbox, or uncompressed RLE to encoded RLE mask.

    Args:
        pyobj: The object(s) to convert.
        h: The height of the mask.
        w: The width of the mask.

    Raises:
        Exception: Input type is not supported.

    Returns:
        The encoded mask.
    """
    # encode rle from a list of python objects
    if isinstance(pyobj, Tensor | BB):
        return frBbox(pyobj, h, w)
    elif isinstance(pyobj, list) and isinstance(pyobj[0], list) and len(pyobj[0]) == 4:  # not working in pycocotools
        return frBbox(Tensor(pyobj), h, w)
    elif isinstance(pyobj, list) and isinstance(pyobj[0], list) and len(pyobj[0]) > 4:
        return frPoly(cast(list[Poly], pyobj), h, w)
    elif isinstance(pyobj, list) and isinstance(pyobj[0], RleObj):
        return frUncompressedRLE(cast(RleObjs, pyobj), h, w)
    # encode rle from single python object
    elif isinstance(pyobj, list) and len(pyobj) == 4:  # not working in pycocotools
        return frBbox(Tensor([pyobj]), h, w)[0]
    elif isinstance(pyobj, list) and len(pyobj) > 4:
        return frPoly([cast(Poly, pyobj)], h, w)[0]
    elif isinstance(pyobj, dict) and "counts" in pyobj and "size" in pyobj:
        return frUncompressedRLE([pyobj], h, w)[0]
    else:
        raise Exception("Input type is not supported.")  # noqa: TRY002
